Формирует короткие ссылки из длинных. Задача №1 [отсюда](grok_system_design_interview).

## Требования
### функциональные требования
 - Создание ссылок.
 - Мы должны редиректить пользователя перешедшего по ссылке с нашим алиасом.
 - Ссылки должны протухать через какое-то время.
 - Пользователь должен иметь возможность установить время жизни ссылки.
 
### нефункциональные требования
 - поддерживать достаточное количество уникальных значений
 - low latency
 - high availability

### дополнительно
 - записывать аналитку
 - предоставлять api для сторонних сервисов

## Оценка данных и определение ограничений
Система расчитана на высокую концентрацию чтения - 1:100-write:read.
Ожидаем:
 - 500М ссылкок в месяц.
 - Храним ссылки в течении 5 лет.

500М ссылкок в месяц на запись -> `100 * 500 = 50B` редиректов в месяц.

Запросов на запись в секунду: `500М / (30 * 24 * 3600) = ~200 URLs/s`

Запросов на чтение в секунду: `100 * 200 = ~20K/s`

*__Хранилище:__*
Количество объектов: `500M * 5 * 12 = 30B`

Предположим, что каждая запись будет равно примерно 500 byte.

Общий объем данных: `30B * 500 bytes = 15 TB`

*__Трафик:__*
Входящий: `200 * 500 bytes = 100 KB/s`

Исходящий: `20K * 500 bytes = ~10 MB/s`

*__Кеш:__*
Используя эврестическое правило 80-20 и условия, что храним кеш в течении одня, получаем:

Запросов в день: `20K * 3600 * 24 = ~1.7B`

20% кешируем и общий объем памяти: `0.2 * 1.7B * 500 bytes = ~170GB`

*_Summary:_*
 - New URLs 200/s
 - URL redirections 20K/s
 -  Incoming data 100KB/s
 -   Outgoing data 10MB/s
 -   Storage for 5 years
 -   15TB Memory for cache 170GB

## Проектируем API
 - createURL(api_dev_key, original_url, custom_alias=None, user_name=None, expire_date=None)
	Parameters: 
	 * api_dev_key (string): The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota.
	 * original_url (string): Original URL to be shortened.
	 * custom_alias (string): Optional custom key for the URL.
	 * user_name (string): Optional user name to be used in encoding.
	 * expire_date (string): Optional expiration date for the shortened URL.
	Returns:
	  (string) A successful insertion returns the shortened URL; otherwise, it returns an error code.
	 
 - deleteURL(api_dev_key, url_key) Where “url_key” is a string representing the shortened URL to be retrieved. A successful deletion returns ‘URL Removed’.

## Выбор базы данных
Так как нам надо:
 - Хранить миллиарды записей.
 - Каждый объект весит меньше КБ.
 - Отсутствуют рел. связи.
 - Нагруженное чтение.
То мы выбираем NoSQL решение. Такие как Cassandra или DynamoBD. 

2 таблицы
__URL__
Hash: varchar(16) PK - до 16 bytes
OriginalURL: varchar(512) - до 512 bytes
CreationDate: datetime - 8 bytes
ExpirationDate: datatime - 8 bytes

__User__
UserID: int PK - 4 bytes
Name: varchar(20) - до 20 bytes
Email: varchar(32) - до 32 bytes
CreationDate: datetime - 8 bytes
LastLogin: datatime - 8 bytes

## Общий вид схемы
![[short urls.png]]

## Детальная проработка отдельных частей
### Encoding URL
Сначала берем хеш от ссылки (MD5 или SHA256/SHA512). Потом кодируем в base64 для повышения количества уникальных значений, если хеш содержит число в 16-ричной системе, то base64 - [A-Z, a-z, 0-9, -, .]. Это дает нам достаточное количество уникальных значений, например:
 - 6 символов: `64^6 = ~68.7B`
 - 7 символов: `64^7 = ~4.4 trillion`
 - 8 символов: `64^8 = ~281 trillion`

Так как результрующее значение base64 будет содержать примерно 21 символ, то нужно выбрать какие сиимволы мы будем отбирать для использования в качестве ключа.

Проблемы, которые могут возникнуть:
1. При попытке генерировать короткую ссылку для одного и того же ресурса разными пользователями будут возникать коллизии. Чтобы этого не происходило, мы можем добавлять какую-либо "соль". Вариантов может быть несколько:
	- завести уникальный генератор последовательности, но придется контролировать его переполнение.
	- от залогиненных пользователей можно добавлять их user_id.
	- мы можем отправлять ошибку и просить пользователя ввести соль самостоятельно.
2. Также можно для начала перегонять каждую переданную строку с URL в единный формат, например меняя все символы на URL-коды.

### Генерация уникальных ключей
Использовать [[Key Generation Service]]. Размер базы данных для хранения всех ключей `6 (characters per key) * 68.7B (unique keys) = 412 GB`.

### Доступ по alias
Пользователь может использовать алиасы, но мне непонятно как в статье хотят решать эту проблему, когда ограничили первичный ключ 6 символами, а алиас разрешили задавать до 16ти. В моем понимании, чтобы это работало адекватно, надо граничные значения в таблице увеличивать и делать равными алиасам.

## Data Partitioning and Replication
Конечно прибегаем к [[Шардирование]] и [[Репликация]].

## Cache
Для ускорения работы мы, конечно, можем использовать кеш. Будем кешировать 20 процентов трафика. Это можно настроить через лимиты использования, например, в Redis. Или можем использовать свою собственную имплементацию LRU-кеша.

## Балансеры
Балансеры ставим перед аппликешн сервером, перед сервером базы данных и сервером кеша.

## Сервис-воркер
Можно поставить воркера, который будет удалять истекшие ссылки из базы.