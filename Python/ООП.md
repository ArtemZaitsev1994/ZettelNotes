Классы - описание создания экземпляров класса. Метаклассы - описание создания классов.

У классов есть своя область видимости и посмотреть доступные имена можно через \__dict\__. 

Атрибут класса != метод класса. Атрибут - это *bound* метод с экземпляром класса, к которому через \__self\__ атрибут и ссылается на функцию через \__func\__.

Метод \__init\__ - инициализатор. Метод \__new\__ - конструктор. [ссылка](https://ru.stackoverflow.com/questions/1025187/%D0%97%D0%B0%D1%87%D0%B5%D0%BC-%D0%BD%D1%83%D0%B6%D0%B5%D0%BD-new-%D0%B8-%D0%BA%D0%B0%D0%BA%D0%BE%D0%B2%D0%BE-%D0%B5%D0%B3%D0%BE-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5)
Если метод \__new\__ не вернет инстанс класса, то вызов \__init\__ не последует.

@staticmethod - объявляет статические методы, т.е. методы, которым не нужен экземпляр класса для работы, только сам класс.

@classmethod - привязывает метод к классу, а не к экземпляру и принимает на вход *cls* вместо *self*.

Инкапсуляция реализуется только номинально при помощи нижних подчеркиваний. Name mangling (подмена имен) - механизм в python, который позволяет хоть как-то скрыть имена классов, которы начинается с двойного нижнего подчеркивания:
```
class Person(object):
	def __init__(self, name):
		self.__name = name

a = Person('Artem')
print(a.__dict__)  # {'_Person__name': 'Artem'}
```

Использовать @property для создания сеттеров и геттеров
```
class Person:
	def __init__(self, name):
		self._name = name
	
	@property
	def name(self):
		return self._name
	
	@name.setter
	def name(self, value):
		self._name = value
```

