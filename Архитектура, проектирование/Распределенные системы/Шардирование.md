Шардирование - разбиение базы данных на части на разных машинах с возможностью опредления на какой конкретно машине находятся данные.

То, что мы называем секцией (partition), в MongoDB, Elasticsearch и SolrCloud называется «шард» (shard), в HBase — «регион» (region), в Bigtable — «сегмент» (tablet), в Cassandra и Riak — «виртуальный узел» (vnode) и в Couchbase — «виртуальный участок» (vBucket). Однако «секционирование» (partitioning) — наиболее часто употребляемый термин, поэтому мы будем использовать его.

Виды:
 - Вертикальное - разбиние по функциональности, по типу чат-таблицы в одной базе, аутентикация в другой. Не сильно поможет если придется потом бить базу из-за сильно больших таблиц.
 - Горизонтальное - разбиение по ключу, используются разные варианты определения к какой базе относится запись. Самый простой - mod(key, n).
 - По каталогу - в системе есть таблица, которая знает где хранятся данные. Где хранятся таблицы - не написано. Таблицы могу стать единой точкой отказа. 

 
 ## Способы генерации ключей по которым будет производиться шардинг
 ### UUID
 Самый простой способ, но может быть избыточен. "Поскольку UUID не имеет равномерного распределения, стоит как-то его преобразовывать, например, с помощью хеширования." - скорее всего речь, о том, что uuid детерменирован временем и от машины на которой генерится - могут быть неравномерности в генерации (но это не точно). 
 
 ### мастер таблица с автоинкрементом
 Просто таблица в главной базе с инкрементируемым айдишником, который потом вставляется в нужный шард. Определение шарда может просиходить также либо по диапозонам, либо по делению.
 
 ### sequence
 Использовать "последовательность" вместо мастер таблицы.
 
 ### auto_increment_increment и auto_increment_offset
 Ставим каждому шарду auto_increment_increment равный количеству шардов, auto_increment_offset равный номеру шарда. Актуально для MySQL, там это из коробки есть
 
### динамический переход между шардами
Вставляем запись в шард, получаем ответ, смотрим на айдишник и если он вышел за пределы, то создаем новый шард и вставляем в него.

https://habr.com/ru/company/oleg-bunin/blog/309330/
https://habr.com/ru/company/oleg-bunin/blog/433370/

## Работа со вторчниыми индексами
Локальный индекс - индексы внутри одной партиции.
Глобальные индексы - нихуя не вкурил про это

### Секционированные индексы по документам
Ситуация, когда вторичные индексы не привязаны к одному шарду, может пораждать проблемы с выборкой. Даже при распараллеливании запросов.

### Секционированные индексы по термам
Данные делим по значениям во вторичных индексах. Тоже могут быть проблемы с чтением, так как выбирать можем слишком по разным индексам.

## Перебалансировка
Со врменем данные распределяются по шардам неравномерно и требуется перебалансировка хранимых данных. 

Балансировка должна соответствовать следующим требованиям:
 - после перебалансировки нагрузка должна распределяться равномерно по всем узлам
 - во время перебалансировки сервис должен оставаться доступным
 - алгоритма перебалансировки должен быть оптимальным без лишних перегонов данных между инстансами

[[Обнаружение сервисов]]